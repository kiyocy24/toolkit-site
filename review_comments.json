{"body":"![high](https://www.gstatic.com/codereviewagent/high-priority.svg)\n\nTo handle potential file reading errors from the `useFileDrop` hook, you should provide an `onError` callback and update the UI to show the error message. This change depends on my other suggestion to add error handling to the `useFileDrop` hook itself.\n\n```suggestion\n    const { isDragging, handleDragOver, handleDragLeave, handleDrop } = useFileDrop({\n        onFileDrop: (content) =\u003e setInput(content),\n        onError: (message) =\u003e setError(message),\n    })\n```","line":49,"path":"src/app/tools/json-formatter/page.tsx"}
{"body":"![high](https://www.gstatic.com/codereviewagent/high-priority.svg)\n\nThis hook has a couple of areas for improvement:\n\n1.  **Unused Import**: `useEffect` is imported but not used.\n2.  **Missing Error Handling**: The `FileReader` API can fail (e.g., a read error), but `reader.onerror` is not handled. This can lead to silent failures and a poor user experience.\n\nI suggest adding an optional `onError` callback to the hook's props to propagate errors and removing the unused import. You should also add a test case for this error path in `use-file-drop.test.ts`.\n\n```typescript\nimport { useCallback, useState } from \"react\"\n\ninterface UseFileDropProps {\n    onFileDrop: (content: string) =\u003e void\n    onError?: (message: string) =\u003e void\n}\n\nexport function useFileDrop({ onFileDrop, onError }: UseFileDropProps) {\n    const [isDragging, setIsDragging] = useState(false)\n\n    const handleDragOver = useCallback((e: React.DragEvent) =\u003e {\n        e.preventDefault()\n        e.stopPropagation()\n        setIsDragging(true)\n    }, [])\n\n    const handleDragLeave = useCallback((e: React.DragEvent) =\u003e {\n        e.preventDefault()\n        e.stopPropagation()\n        setIsDragging(false)\n    }, [])\n\n    const handleDrop = useCallback(\n        (e: React.DragEvent) =\u003e {\n            e.preventDefault()\n            e.stopPropagation()\n            setIsDragging(false)\n\n            const files = e.dataTransfer.files\n            if (files \u0026\u0026 files.length \u003e 0) {\n                const file = files[0]\n                const reader = new FileReader()\n                reader.onload = (event) =\u003e {\n                    if (event.target?.result \u0026\u0026 typeof event.target.result === \"string\") {\n                        onFileDrop(event.target.result)\n                    }\n                }\n                reader.onerror = () =\u003e {\n                    onError?.(\"Failed to read file.\")\n                }\n                reader.readAsText(file)\n            }\n        },\n        [onFileDrop, onError]\n    )\n\n    return {\n        isDragging,\n        handleDragOver,\n        handleDragLeave,\n        handleDrop,\n    }\n}\n```","line":49,"path":"src/hooks/use-file-drop.ts"}
{"body":"![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nFor better readability and consistency with the project's style (e.g., `textarea.tsx`), you can use the `cn` utility to conditionally apply classes. You'll need to import `cn` from `@/lib/utils`.\n\n```suggestion\n                            className={cn(\"relative\", isDragging \u0026\u0026 \"ring-2 ring-primary ring-offset-2\")}\n```","line":119,"path":"src/app/tools/json-formatter/page.tsx"}
{"body":"![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThis test contains many comments and some confusing code that makes it hard to understand. The logic can be simplified to directly target the drop zone element and test the drag-and-drop visual feedback, improving readability and maintainability.\n\n```\n        render(\u003cJsonFormatterPage /\u003e)\n\n        const textarea = screen.getByPlaceholderText(/paste your json here/i)\n        const wrapper = textarea.parentElement\n\n        expect(wrapper).toBeInTheDocument()\n\n        fireEvent.dragOver(wrapper!)\n\n        expect(screen.getByText('Drop file here')).toBeInTheDocument()\n\n        fireEvent.dragLeave(wrapper!)\n        expect(screen.queryByText('Drop file here')).not.toBeInTheDocument()\n```","line":167,"path":"src/app/tools/json-formatter/page.test.tsx"}
{"body":"![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nTo ensure that `global.FileReader` is always restored to its original value, even if an assertion within the test fails, it's safer to use a `try...finally` block. This makes the test more robust.\n\n```typescript\n        const originalFileReader = global.FileReader\n        try {\n            // Use a Promise to wait for FileReader to be called\n            await new Promise\u003cvoid\u003e((resolve) =\u003e {\n                class MockFileReader {\n                    onload: ((e: ProgressEvent\u003cFileReader\u003e) =\u003e any) | null = null\n                    readAsText() {\n                        setTimeout(() =\u003e {\n                            this.onload?.({ target: { result: \"test content\" } } as unknown as ProgressEvent\u003cFileReader\u003e)\n                            resolve()\n                        }, 0)\n                    }\n                }\n                global.FileReader = MockFileReader as any\n\n                act(() =\u003e {\n                    result.current.handleDrop(e)\n                })\n            })\n\n            expect(result.current.isDragging).toBe(false)\n            expect(onFileDrop).toHaveBeenCalledWith(\"test content\")\n        } finally {\n            global.FileReader = originalFileReader\n        }\n```","line":78,"path":"src/hooks/use-file-drop.test.ts"}
